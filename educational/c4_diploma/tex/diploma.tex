 \newcommand{\BibTeX}{{\sc Bib}\TeX}
 % \renewcommand{\appendixtocname}{Приложение}
 % \renewcommand{\appendixpagename}{Приложение}

 % \renewcommand{\arraystretch}{0.75}
\renewcommand{\tabcolsep}{5mm}
% \theoremstyle{plain}
\lstset{xleftmargin=5mm}

\lstset{
    breaklines=true,
    basicstyle=\ttfamily,
     postbreak=\raisebox{0ex}[0ex][0ex]{\ensuremath{\color{red}\hookrightarrow\space}}
}

\tableofcontents
\clearpage

\section*{Введение}
\addcontentsline{toc}{section}{Введение}
  Задача о клике является важной проблемой в теории графов.
  Она имеет много практических применений, но время работы существующих алгоритмов
  растёт экспоненциально, поэтому для поиска клик в больших графах приходится тратить
  много времени и вычислительных ресурсов. Поэтому рассматривается всё больше новых
  альтернативных подходов, которые могут быстрее решать задачу о клике, но ни один
  из них не работает достаточно точно.

  В данной работе рассматривается использование псевдофизической симуляции в задаче
  о клике.

  Задачи:
  % \begin{enumerate}
  
  1. рассмотреть возможность использование такого подхода в задаче о клике;
  
  2. написать программу, реализующую псевдофизическую симуляцию;
  
  3. произвести численные эксперименты;
  
  4. оценить применимость подхода к различным вариациям задачи о клике.
  % \end{enumerate}

  Научная ценность заключается в том, что рассматриваемый подход является, во-первых,
  новаторским --- ранее ничего подобного не применялось, а, во-вторых, очень перспективным:
  если он окажется применимым и будет работать надёжно, то станет самым асимптотически
  быстрым алгоритмом, решающим задачу о клике.

\section{Обзор литературы}
  \subsection{Задачи о кликах}
  В теории графов задача о клике --- вычислительная проблема поиска клик
  (подмножеств вершин, попарно смежных друг другу;
  иными словами, полные подграфы) в графах.

  Задача имеет несколько формулировок, в зависимости от того,
  какие клики и какую информацию о кликах требуется найти.

  Наиболее распространённые формулировки
  % \begin{enumerate}
    
    1.
    Найти наибольшую клику (клику с наибольшим количеством вершин);
    
    2.
    Найти клику максимального веса во взвешенном графе;
    
    3.
    Найти все максимальные клики (клики, которые нельзя расширить);
    
    4.
    Поиск или проверка на существование в графе клики заданного размера.
  % \end{enumerate}
  
  % Далее в работе будет рассматриваться только задача поиска наибольшей клики.
  
  \subsection{История и приложения}
    Исследование полных подграфов началось в математике задолго до появления
    термина \guillemotleftклика\guillemotright.
    Например, полные подграфы появляются в математической литературе при
    переформулировке теории Рамсея в терминах теории графов Эрдёшем и Зекересом 
    (Erdős \& Szekeres, 1935)
    \cite{erdios1935combinatorial}.
    Сам  термин \guillemotleftклика\guillemotright и задача поиска всех максимальных клик в графе пришли из 
    социологии, где полные подграфы использовались для моделирования социальных
    клик --- групп людей, где все друг друга знают.
    Luce and Perry (1949) \cite{luce1949method} использовали графы, чтобы моделировать социальные
    сети и перенесли многие термины из социологии в теорию графов.
    Они первыми стали называть полные подграфы кликами.
    Первый алгоритм, решающий задачу о клике был предложен Harary \& Ross (1957),
    \cite{harary1957procedure}
    которых интересовало \guillemotleftсоциологическое\guillemotright применение.

    Алгоритмы поиска клик используются в химии, чтобы найти химикаты, которые
    соответсвуют заданной структуре \cite{rhodes2003clip},
    для моделирования молекулярной стыковки и 
    участков связывания химических реакций \cite{kuhl1984combinatorial}.
    Клики можно использовать чтобы найти схожие структуры внyтри различных молекул \cite{national1995mathematical}.
    В этих приложениях формируется граф, в котором каждая вершина представляет
    совпавшую пару атомов, каждый из которых взят из разных молекул.
    Две вершины соединены ребром, если совпадения, которые они представляют,
    совместимы между собой \cite{muegge2001small}.
    совместимость может означать, например, что расстояния между атомами между
    двумя молекулами равны (с заданной точностью).
    Клика в таком графе представляет множество пар атомов в котором все совпадения
    совместимы между собой.

    В биоинформатике алгоритмы поиска клик используются для построения
    филогенетических деревьев \cite{day1986computational},
    предсказания структур белков \cite{samudrala1998graph} и поиска близко
    взаимодействующих белковых кластеров \cite{spirin2003protein}.

    В математике гипотеза Келлера о том, что при замощении пространства
    гиперкубами всегда найдутся два гиперкуба, которые будут соприкасаться грань
    к грани, была опровергнута Лагариасом и Шором (Lagarias and Shor, 1992) \cite{lagarias1992keller}, 
    которые использовали алгоритм поиска клик в ассоциированном графе для построения 
    контрпримера.

  \subsection{Известные алгоритмы}
    Наиболее известные алгоритмы на общих графах
    % \begin{enumerate}
      
      1. Tarjan \& Trojanowski (1977) \cite{tarjan1977finding};
      
      2. Bron–Kerbosch algorithm \cite{bron1973algorithm};
      
      3. Robson (2001) \cite{robson2001finding}.
    % \end{enumerate}
    
    Основной недостаток всех этих алгоритмов в том, что они имеют экспоненциальную
    сложность и лучшее, чего пока удалось добиться --- это снижения показателя экспоненты.
    Благодаря этому, например, алгоритм Робсона \cite{robson2001finding} очень быстро
    работает на небольших графах или в простых случаях, в то время как на больших
    графах всё равно работает очень медленно.
    При современном уровне развития технологий, среднестатистические компьютеры за
    приемлемое время могут обабатывать графы не более 200 вершин, для графов с большим
    количеством вершин требуется применение суперкомпьютеров.

    % Для того, чтобы преодолеть это ограничение, ведётя разработка приближённых или
    % эвристических алгоритмов.  

    % На данный момент работа ведётся, по сути, в трёх направлениях:
    % понижение основания экспоненты, от которой зависит время работы алгоритма;
    % поиск полиномиальных решений для специальных случаев;
    % поиск приближённых или эвристических алгоритмов.

    % Привести пример алгоритма для частного случая
    % Добавить приближённых алгоритмов и написать, почему они плохие
    % Расширить критику известных алгоритмов на общих графах


  \subsection{Исследуемый подход}
    Несовершенство точных алгоритмов подталкивает исследователей на поиск 
    приближённых решений.

    В данной работе рассматривается использование псевдофизической симуляции для
    поиска приближённого решения задачи о наибольшей клике.

    Вершины помещаются в $n$-мерное пространство, затем рассчитываются силы
    взаимодействия между вершинами.
    Главное правило данной симуляции заключается в том, что вершины, соединённые
    ребром, притягиваются, а не соединённые отталкиваются.
    Для каждой пары вершин рассчитывается сила взаимодействия и после того, как
    все силы будут рассчитаны, производится шаг симуляции.
    Во время этого шага к каждой вершине применяются рассчитанные силы,
    вычисляются мгновенные скорости вершин и их новые координаты.
    Симуляция производится в реальном времени, тоесть время вычисления и
    применения сил не превышает 30 милисекунд.
    Положение вершин постоянно меняется и, так как в клике все вершины притягиваются
    друг к другу, постепенно они слетаются в одну область пространства.
    Предположительно, наибольшая группа слетевшихся вершин и будет наибольшей кликой
    в исследуемом графе.

    Далее детально рассматривается реализация данной псевдофизической симуляции.
    Для простоты было выбрано двумерное пространство и исследуются различные типы
    взаимодействия вершин, а также дополнительные параметры, которые влияют на ход 
    и результат симуляции.
    \clearpage

\section{Формализация метода}
  В этом разделе приводятся все необходимые базовые определения, формальное описание
  задачи и алгоритма, по которому работает симуляция.

  \subsection{Базовые определения}
    \begin{definition}\label{graph_def}
      Граф --- упорядоченная пара множеств $\left(V, E\right)$, где $V$ --- это непустое множество
      вершин или узлов, а $E$ --- множество (неупорядоченных) пар вершин, называемых
      рёбрами.

      $|V|$ --- порядок графа;

      $|E|$ --- размер графа;
    \end{definition}

    \begin{definition}
    \label{full_graph_def}
      Полный граф --- граф, в котором каждая вершина соединена ребром с другой
      вершиной.
    \end{definition}

    \begin{definition}
    \label{subgraph_def}
      Подграф --- граф, содержащий некоторое подмножество вершин данного графа и 
      некоторое подмножество соединяющих их рёбер.
    \end{definition}

    \begin{definition}
    \label{clique_def}
      Клика --- полный подграф данного графа.
    \end{definition}

    \begin{definition}
    \label{dense_graph_def}
      Плотный граф --- граф, в котором число рёбер близко к максимальному.

      Граф с противоположным свойством, имеющим малое число рёбер, называется
      разреженным графом.
    \end{definition}

    \begin{definition}
    \label{density_def}
      Для неориентированного простого графа плотность графа \cite{coleman1983estimation}
      определеяется как
      \begin{equation}
        D = \frac{2|E|}{|V|\left(|V| - 1\right)}
      \end{equation}

      Максимальная плотность равна $1$ (для полного графа), минимальная равна $0$
      (для графа без рёбер).
    \end{definition}

    \begin{definition}
    \label{maximal_clique_def}
      Максимальная клика --- клика, которую нельзя расширить, добавив ещё одну
      смежную вершину.
    \end{definition}

    \begin{definition}
    \label{maximum_clique_def}
      Наибольшая клика --- такая максимальная клика в графе, что не существует
      клики большего размера.
    \end{definition}
  \subsection{Формулировка задачи}
    Дан граф $G = \left(V, E\right)$. Обозначения как в определении (\ref{graph_def}).

    Задача: найти наибольшую клику в графе $G$.

    Метод решения: псевдофизическая симуляция, в которой вершины расположены в
    двумерном пространстве и вершины, связанные ребром притягиваются, а не связанные
    отталкиваются.

    Цели исследования
    % \begin{enumerate}

      1.
      Определить возможность применения исследуемого метода;
      
      2.
      Определить границы применимости метода;
      
      3.
      Выяснить, как различные параметры симуляции действуют на её ход.
    % \end{enumerate}
  \subsection{Описание алгоритма}
    На (рис. \ref{algorithm_pic}) представлена блок-схема одного шага симуляции,
    который выполняется 30-60 раз в секунду.

    \begin{figure}
      \centering
      \includegraphics[height=25cm]{algorithm.png}
      \caption{Блок-схема одного шага симуляции.}
      \label{algorithm_pic}
    \end{figure}

\section{Результаты}
  \subsection{Инструменты}
  \label{tools_subsect}
    Программа, реализующая исследуемый медод была написана на языке C++ с использованием
    бибилиотек SFML и Box2D.

    Язык C++ был выбран потому, что это компилируемый язык достаточно высокого
    уровня с высокой скоростью выполнения программ, что требовалось для обеспечения
    работы симуляции в реальном времени.
    В C++ имеется широкий набор возможностей для построения крупных и высокопроизводительных
    программных комплексов.

    Наиболее широко использовались такие конструкции стандарта 2011 года как

    % \begin{enumerate}
      
      1. цикл по элементам контейнера, который предотвращает выход за пределы массива;
      
      2. \lstinline{enum class}, который запрещает любое преобразование базовых типов к типу 
      перечисления;
      
      3. указатель \lstinline{std::unique_ptr}, который помогает предотвратить утечки памяти.
    % \end{enumerate}
    
    Для визуализации работы исследуемого метода была выбрана библиотека SFML, 
    потому что она предоставляет простой, и, вместе с тем, достаточный для данной
    задачи интерфейс.
    От библиотеки требовалось только отображать вершины на экране и обрабатывать
    очень простой ввод с клавиатуры, поэтому применение более продвинутых фреймворков
    (например, Unity), было нецелесообразным.

    Изначально добавление других библиотек не планировалось и шаг симуляции на 
    (рис. \ref{algorithm_pic})
    был реализован как часть программы, но эта реализация имела ряд проблем.
    Сначала силы рассчитывались неправильно, потом, из-за отстутствия определения
    столкновений, вершины оказывались слишком близко друг к другу, после чего разлетались
    с космическими скоростями и силы взаимодействия не могли их остановить.
    Решить эти проблемы был призван физический движок реального времени Box2D, предназначенный
    для работы с двумерными объектами.
    После его внедрения шаг симуляции стал обрабатываться средствами Box2D и необходимость
    в дополнительном коде отпала.
    Проблема сближения была решена добавлением физического размера вершинам, которые
    стали полноценными абсолютно твёрдыми телами, расстояние между их центрами всегда
    больше двух радиусов вершины.

  \subsection{Виды гравитации}
    Самым важным параметром симуляции является функция, которая определяет
    характер гравитационного взаимодействия между вершинами.
    В подразделах указан вид зависимости силы гравитации от расстояния, вид
    зависимости от других параметров выглядит следующим образом:
    \begin{equation}
      F = f\left( R \right) \cdot  G \cdot m_i \cdot m_j \cdot E;
    \end{equation}
    $F$ --- сила взаимодействия между $i$-й и $j$-й вершинами графа;\\
    $f\left( R \right)$ --- одна из шести функций зависящая от расстояния,
    определяющих характер гравитационного взаимодействия. О каждой из этих функций
    будет написано более подробно в соответствующем разделе. 
    $G$ --- параметр гравитационной постоянной;\\
    $m_i, m_j$ --- массы $i$-й и $j$-й вершины графа соответственно (подробнее о
    массах ниже).\\
    \begin{equation}
      E =
      \begin{cases}
        1, a_{ij} = 1 \\
        - D \cdot n, a_{ij} = 0 \\
      \end{cases}
    \end{equation}
    $a_{ij}$ --- элемент матрицы смежности исследуемого графа;
    $a_{ij} = 1$, если ребро есть и $a_{ij} = 0$, если ребра нет;\\
    $D$ --- плотность графа из определения (\ref{density_def}).\\
    $n$ --- количество вершин в графе.

    Стоит пояснить смысл формулы для коэффициента $E$.
    Изначально формула имела вид
    \begin{equation}
      E =
      \begin{cases}
        1, a_{ij} = 1 \\
        - 2, a_{ij} = 0 \\
      \end{cases}
    \end{equation}
    В общем и целом, она работала неплохо, но в ситуации, когда вершина не входила
    в клику и имела связи больше чем с половиной вершин из клики, результирующая
    сила притяжения становилась больше, чем сила отталкивания и вершина прилипала
    к клике, хотя в неё не входила.
    Чтобы избежать таких ситуаций константа $-2$ была заменена на $-n$.
    Коэффициент $D$ был добавлен для того, чтобы снизить силу отталкивания в графах с
    достаточно малым количеством рёбер.

    Не смотря на понижающий коэффициент, разность между силами притягивания и отталкивания
    может быть очень большой уже для относительно небольших и не очень плотных графов.
    Например, в графе из 50 вершин с плотностью 0.4 разница сил притягивания и отталкивания
    двадцатикратная.
    Большие силы придают вершинам большие ускорения, скорости становятся огромными
    и, во-первых, возникают неточности в самой симуляции, а, во-вторых, быстрая
    свободная вершина может попасть в уже слипшуюся клику и разбить её.
    Чтобы этого избежать, пользователю программы предоставляется возможность управлять
    гравитационной постоянной.
    В дальнейших исследованиях планируется найти способ вычисления этого параметра
    специально для каждого графа и каждого конкретного характера гравитации.
    
    \subsubsection{Постоянная}
      \begin{equation}
      \label{gconst_eq}
        f(R) = const
      \end{equation}

      Самая первая функция, с которой производились эксперименты.
      На небольших графах даже эта тривиальная функция позволяет находить клики,
      но для больших графов не подходит.
      Во время первых экспериментов обнаружились и первые проблемы: слипшиеся клики 
      часто разбивались свободными вершинами; клики слипались и улетали в неизвестном
      направлении, что привело к поиску способов удерживать клики в одной области.
      Изменение константы на результаты эксперимента почти никак не повлияло.

      На основе численных экспериментов с данным видом гравитации была выдвинута
      гипотеза о том, что функции, которые растут при $R \rightarrow 0+$ и монотонно убывают при
      $R \rightarrow \infty$ (оставаясь положительными), будут лучше подходить
      для симуляции (под \guillemotleftлучше\guillemotright
      подразумевается, что клики будут сходиться быстрее и уже сошедшиеся клики
      будет сложнее разорвать).
    \subsubsection{Линейная и классическая}
    \begin{equation}
    \label{glin_eq}
      f(R) = \frac{1}{R}
    \end{equation}
    % \subsubsection{Классическая}
    \begin{equation}
    \label{gclass_eq}
      f(R) = \frac{1}{R^2}
    \end{equation}
    Гипотеза отчасти подтвердилась, когда были проведены эксперименты с
    линейным\footnotemark (\ref{glin_eq}) и классическим (\ref{gclass_eq})
    законами гравитации. 
    В обоих случаях характер симуляции был примерно одинаковым: вершины движутся
    достаточно медленно, клики сильно слипаются и свободные вершины не могут их 
    разбить или разорвать.
    Из всех исследованных видов гравитации эти два --- однозначно лучшие.
    \footnotetext{
      Подразумевается, что линейная (как и логарифмическая, и радикальная)
      функция стоит в знаменателе. 
    }

    \subsubsection{Логарифмическая и радикальная}
    \begin{equation}
    \label{glog_eq}
      f(R) = \frac{1}{log_2\left(R + 1 \right)}
    \end{equation}
    \begin{equation}\label{grad_eq}
      f(R) = \frac{1}{\sqrt{R}}
    \end{equation}

    По сравнению с линейной и классической, логарифмическая и радикальные функции
    (\ref{glog_eq}) и (\ref{grad_eq}) медленно растут при $R \rightarrow 0+$ и
    медленно убывают при $R \rightarrow \infty$.
    Это приводит к тому, что (в сравнении) дальние вершины взаимодействуют сильно,
    а ближние слабо. Средняя скорость вершин больше, клики плохо слипаются и легче
    разбиваются.
    Численные эксперименты даже на простых графах показывают, что использование
    данных видов гравитации крайне неэффективно.

    \subsubsection{Ступенчатая}
    \begin{equation}
    \label{gstep_eq}
      f(R) =
      \begin{cases}
        4, R < 1 \\
        1, R \geqslant 1 \\
      \end{cases}
    \end{equation}

    Уже отмечалось, что основным недостатком функций (\ref{glog_eq}) и (\ref{grad_eq})
    является слабое взаимодействие близких вершин и сильное взаимодействие дальних.
    Функция (\ref{gstep_eq}) является, с одной стороны, попыткой всё-таки использовать линейную
    функцию для описания характера гравитации, с другой, демонстрацией того, что
    гравитация не обязательно должна задаваться дифференцируемой функцией.
    В заданном виде функция работает значительно лучше, чем постоянная, логарифмическая
    и радикальная, особенно на небольших графах, но на больших графах всё ещё поведение
    вершин слишком хаотичное.
    Возможно, это объясняется тем, что пороговое значение расстояния и сами значения
    функции заданы жёстко.
    Есть шанс, что если вычислять эти значения для каждого графа, то данный вид
    взаимодействия может работать не лучше, чем линейный или классический.

  % \subsection{Коробка и чёрная дыра}

  % \subsection{Масса вершин}

  \subsection{Пример работы программы}
    Граф подгружается из файла, заданного формата: первое число --- количество 
    вершин в графе; дальше следует список пар чисел, где каждое число --- индекс
    вершины в списке вершин графа; конец списка вершин обозначается парой 
    \lstinline{-1 -1}.
    При нажатии на клавишу \lstinline{Space}, начинается симуляция, нажатием на
    эту же клавишу она приостанавливается.
    Перезапустить симуляцию можно клавишей \lstinline{R}.
    На (рис. \ref{start_pic}) и (рис. \ref{end_pic}) можно видеть пример работы программы с
    загруженным графом из 150 вершин.
    \begin{figure}[h]
      \centering
      \includegraphics[width=\textwidth]{Screenshot-Diploma}
      \caption{Граф из 150 вершин в начале симуляции.}
      \label{start_pic}
    \end{figure}

    \begin{figure}[h]
      \centering
      \includegraphics[width=\textwidth]{Screenshot-Diploma-1}
      \caption{Граф из 150 вершин в конце симуляции.}
      \label{end_pic}
    \end{figure}

  \clearpage
% \section{Результаты}
%   \subsection{Гравитационная постоянная}
\section*{Заключение}
\addcontentsline{toc}{section}{Заключение}
  В процессе подготовки дипломной работы была написана программа, реализующая метод псевдофизической симуляции, после чего были проведены численные эксперименты, показавшие состоятельность данного метода, несмотря на некторые ограничения.
  Все слипшиеся во время симуляции вершины можно смело считать кликами, хотя зачастую нельзя сказать, какие из найденных клик максимальные, потому что часто клики пересекаются.
  При пересечении клик вершины, входящие в пересечение, будут перетянуты большей кликой
  в виду того, что у большей клики больше масса.

  Основным недостатком исследуемого подхода является непредсказуемость времени работы.
  Для графов с одинаковым количеством вершин и рёбер время работы может отличаться в разы.
  В дальнейшем планируется поиск дополнительных методов, которые бы позволили уменьшить разброс времени работы и сделать его более предсказуемым.

  В данной работе для простоты и наглядности рассматривалось двумерное пространство, хотя размерность тоже является параметром и поведение симуляции при его изменении требует дополнительного исследования.
  В текущем варианте программы большинство параметров задаётся пользователем, и она требует дополнительной настройки для того, чтобы получить приемлемый результат.
  Необходимо исследовать зависимость этих параметров от входных данных: если они будут вычисляться для каждого графа перед запуском симуляции, это увеличит удобство пользования программой и повысит надёжность получаемых результатов.
